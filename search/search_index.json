{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Index","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Just a library of things to tinker with.</p>"},{"location":"changelog/","title":"BagOfStuff ChangeLog","text":""},{"location":"changelog/#v001","title":"v0.0.1","text":"<p>Released: 2026-01-31</p> <ul> <li>Initial release to PyPI.</li> </ul>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2026 Dave Pearson &lt;davep@davep.org&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n</code></pre>"},{"location":"library-contents/itertools/","title":"bagofstuff.itertools","text":"<p>Tools for iterating or working on iterable things.</p>"},{"location":"library-contents/itertools/#bagofstuff.itertools.Direction","title":"Direction","text":"<pre><code>Direction = Literal['forward', 'backward']\n</code></pre> <p>Directions used with <code>starting_at</code>.</p>"},{"location":"library-contents/itertools/#bagofstuff.itertools.starting_at","title":"starting_at","text":"<pre><code>starting_at(\n    items: Iterable[T],\n    start_at: int = 0,\n    direction: Direction = \"forward\",\n) -&gt; Iterator[T]\n</code></pre> <p>Create an iterator of all items starting at a given point.</p> <p>This function creates an iterator of all the items in the initial iterable, starting at the given point and wrapping around the end if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>Iterable[T]</code> <p>The items to iterate over.</p> required <code>int</code> <p>The item to start out at.</p> <code>0</code> <code>Direction</code> <p>The direction to iterate in.</p> <code>'forward'</code> <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>An iterable of all the items starting at the given point.</p>"},{"location":"library-contents/itertools/#bagofstuff.itertools.starting_at(items)","title":"<code>items</code>","text":""},{"location":"library-contents/itertools/#bagofstuff.itertools.starting_at(start_at)","title":"<code>start_at</code>","text":""},{"location":"library-contents/itertools/#bagofstuff.itertools.starting_at(direction)","title":"<code>direction</code>","text":""},{"location":"library-contents/pipe/","title":"bagofstuff.pipe","text":"<p>Provides a tool for creating a 'pipe' of functions.</p>"},{"location":"library-contents/pipe/#bagofstuff.pipe.Pipe","title":"Pipe","text":"<pre><code>Pipe(*functions: Callable[[Any], Any])\n</code></pre> <p>A class that provides a simple function pipeline.</p> <p><code>Pipe</code> is a little like Python's own <code>partial</code> except that:</p> <ol> <li>It only allows for one positional parameter.</li> <li>It allows for a whole chain of functions.</li> </ol> Example <pre><code>from bagoftools.pipe import Pipe\n\nshortest_len = Pipe[str, int](str.trim, len)\n\nprint(shortest_len(\"      this is padded     \"))\n</code></pre> <p>As well as passing a list of functions when creating the pipe, they can also be added afterwards:</p> <pre><code>from bagoftools.pipe import Pipe\n\nshortest_len = Pipe[str, int]()\nshortest_len |= str.trim\nshortest_len |= len\n\nprint(shortest_len(\"      this is padded     \"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>Callable[[Any], Any]</code> <p>The initial set of functions.</p> <code>()</code>"},{"location":"library-contents/pipe/#bagofstuff.pipe.Pipe(functions)","title":"<code>functions</code>","text":""},{"location":"library-contents/pipe/#bagofstuff.pipe.Pipe.__call__","title":"__call__","text":"<pre><code>__call__(initial: TInitial) -&gt; TResult\n</code></pre> <p>Execute the pipeline.</p> <p>Given an initial value, it is passed to the first function in the pipeline, the result is then passed as the argument to the next function in the pipeline, and so on. The result is the result of the call to the last function in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>TInitial</code> <p>The initial value.</p> required <p>Returns:</p> Type Description <code>TResult</code> <p>The result of the pipeline.</p>"},{"location":"library-contents/pipe/#bagofstuff.pipe.Pipe.__call__(initial)","title":"<code>initial</code>","text":""},{"location":"library-contents/pipe/#bagofstuff.pipe.Pipe.__or__","title":"__or__","text":"<pre><code>__or__(\n    function: Callable[[Any], Any],\n) -&gt; Pipe[TInitial, TResult]\n</code></pre> <p>Add another function to the pipeline.</p> Example <p>Assuming a pipeline called <code>tidy</code>, a call to <code>strip</code> could be added like this:</p> <pre><code>tidy |= str.strip\n</code></pre>"}]}